#!/usr/bin/env python3
"""
Vulnerability Scanner
Author: DevOps-CommandCenter
Description: Comprehensive vulnerability scanning for systems and applications
"""

import subprocess
import json
import logging
import argparse
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
import requests
import re

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class Vulnerability:
    cve_id: str
    severity: str
    title: str
    description: str
    affected_component: str
    component_version: str
    published_date: str
    cvss_score: float
    exploit_available: bool
    remediation: str
    references: List[str]

class VulnerabilityScanner:
    def __init__(self):
        self.nvd_api_key = os.getenv('NVD_API_KEY', '')
        self.nvd_base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    
    def scan_system_vulnerabilities(self, scan_type: str = 'all') -> List[Vulnerability]:
        """Perform comprehensive vulnerability scanning"""
        vulnerabilities = []
        
        if scan_type in ['all', 'system']:
            vulnerabilities.extend(self._scan_system_packages())
        
        if scan_type in ['all', 'docker']:
            vulnerabilities.extend(self._scan_docker_images())
        
        if scan_type in ['all', 'dependencies']:
            vulnerabilities.extend(self._scan_application_dependencies())
        
        if scan_type in ['all', 'network']:
            vulnerabilities.extend(self._scan_network_services())
        
        return vulnerabilities
    
    def _scan_system_packages(self) -> List[Vulnerability]:
        """Scan installed system packages for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Get installed packages (Linux)
            if self._is_linux():
                packages = self._get_installed_packages()
                
                for package in packages:
                    pkg_vulns = self._check_package_vulnerabilities(package['name'], package['version'])
                    vulnerabilities.extend(pkg_vulns)
            
        except Exception as e:
            logger.error(f"Error scanning system packages: {str(e)}")
        
        return vulnerabilities
    
    def _is_linux(self) -> bool:
        """Check if running on Linux"""
        try:
            return subprocess.run(['uname'], capture_output=True, text=True).stdout.strip().lower() == 'linux'
        except:
            return False
    
    def _get_installed_packages(self) -> List[Dict]:
        """Get list of installed packages"""
        packages = []
        
        try:
            # Try different package managers
            if subprocess.run(['which', 'dpkg'], capture_output=True).returncode == 0:
                # Debian/Ubuntu
                result = subprocess.run(['dpkg', '-l'], capture_output=True, text=True)
                for line in result.stdout.split('\n'):
                    if line.startswith('ii'):
                        parts = line.split()
                        if len(parts) >= 3:
                            packages.append({
                                'name': parts[1],
                                'version': parts[2],
                                'manager': 'dpkg'
                            })
            
            elif subprocess.run(['which', 'rpm'], capture_output=True).returncode == 0:
                # RedHat/CentOS
                result = subprocess.run(['rpm', '-qa', '--queryformat', '%{NAME} %{VERSION}\n'], capture_output=True, text=True)
                for line in result.stdout.strip().split('\n'):
                    if line:
                        parts = line.split()
                        if len(parts) >= 2:
                            packages.append({
                                'name': parts[0],
                                'version': parts[1],
                                'manager': 'rpm'
                            })
        
        except Exception as e:
            logger.error(f"Error getting installed packages: {str(e)}")
        
        return packages
    
    def _check_package_vulnerabilities(self, package_name: str, version: str) -> List[Vulnerability]:
        """Check for vulnerabilities in a specific package"""
        vulnerabilities = []
        
        try:
            # Query NVD database
            params = {
                'keywordSearch': package_name,
                'keywordExactMatch': 'true'
            }
            
            if self.nvd_api_key:
                params['apiKey'] = self.nvd_api_key
            
            response = requests.get(self.nvd_base_url, params=params, timeout=30)
            
            if response.status_code == 200:
                data = response.json()
                
                for cve in data.get('vulnerabilities', []):
                    cve_data = cve['cve']
                    
                    # Check if this CVE affects our version
                    if self._affects_version(cve_data, version):
                        vulnerability = self._parse_cve_data(cve_data, package_name, version)
                        vulnerabilities.append(vulnerability)
        
        except Exception as e:
            logger.warning(f"Could not check vulnerabilities for {package_name}: {str(e)}")
        
        return vulnerabilities
    
    def _affects_version(self, cve_data: Dict, current_version: str) -> bool:
        """Check if CVE affects the current version"""
        # Simplified version checking - in practice, use more sophisticated version comparison
        configurations = cve_data.get('configurations', [])
        
        for config in configurations:
            for node in config.get('nodes', []):
                for cpe_match in node.get('cpeMatch', []):
                    if 'versionStartIncluding' in cpe_match or 'versionEndIncluding' in cpe_match:
                        # This is a simplified check - real implementation would be more complex
                        return True
        
        return False
    
    def _parse_cve_data(self, cve_data: Dict, component: str, version: str) -> Vulnerability:
        """Parse CVE data into Vulnerability object"""
        cve_id = cve_data['id']
        description = cve_data['descriptions'][0]['value'] if cve_data.get('descriptions') else 'No description available'
        
        # Get CVSS score
        cvss_score = 0.0
        for metric in cve_data.get('metrics', []):
            if 'cvssMetricV31' in metric:
                cvss_score = metric['cvssMetricV31'][0]['cvssData']['baseScore']
                break
            elif 'cvssMetricV30' in metric:
                cvss_score = metric['cvssMetricV30'][0]['cvssData']['baseScore']
                break
            elif 'cvssMetricV2' in metric:
                cvss_score = metric['cvssMetricV2'][0]['cvssData']['baseScore']
                break
        
        # Determine severity
        if cvss_score >= 9.0:
            severity = 'critical'
        elif cvss_score >= 7.0:
            severity = 'high'
        elif cvss_score >= 4.0:
            severity = 'medium'
        else:
            severity = 'low'
        
        # Check for exploit availability
        exploit_available = False
        if 'cveId' in cve_data and 'references' in cve_data:
            for ref in cve_data['references']:
                if 'exploit' in ref.get('url', '').lower():
                    exploit_available = True
                    break
        
        # Generate remediation
        remediation = f"Update {component} to latest stable version"
        
        return Vulnerability(
            cve_id=cve_id,
            severity=severity,
            title=cve_data.get('id', 'Unknown'),
            description=description,
            affected_component=component,
            component_version=version,
            published_date=cve_data.get('published', 'Unknown'),
            cvss_score=cvss_score,
            exploit_available=exploit_available,
            remediation=remediation,
            references=[ref['url'] for ref in cve_data.get('references', [])]
        )
    
    def _scan_docker_images(self) -> List[Vulnerability]:
        """Scan Docker images for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Get Docker images
            result = subprocess.run(['docker', 'images', '--format', '{{.Repository}}:{{.Tag}}'], 
                                 capture_output=True, text=True)
            
            if result.returncode == 0:
                images = result.stdout.strip().split('\n')
                
                for image in images:
                    if image and '<none>' not in image:
                        image_vulns = self._scan_docker_image(image)
                        vulnerabilities.extend(image_vulns)
        
        except Exception as e:
            logger.error(f"Error scanning Docker images: {str(e)}")
        
        return vulnerabilities
    
    def _scan_docker_image(self, image: str) -> List[Vulnerability]:
        """Scan a specific Docker image"""
        vulnerabilities = []
        
        try:
            # Use docker scout or trivy if available
            if subprocess.run(['which', 'trivy'], capture_output=True).returncode == 0:
                # Use Trivy for vulnerability scanning
                result = subprocess.run(['trivy', 'image', '--format', 'json', image], 
                                     capture_output=True, text=True)
                
                if result.returncode == 0:
                    data = json.loads(result.stdout)
                    
                    for result in data.get('Results', []):
                        for vuln in result.get('Vulnerabilities', []):
                            vulnerability = Vulnerability(
                                cve_id=vuln.get('VulnerabilityID', 'Unknown'),
                                severity=vuln.get('Severity', 'Unknown').lower(),
                                title=vuln.get('Title', 'Unknown'),
                                description=vuln.get('Description', 'No description'),
                                affected_component=result.get('Type', 'Unknown'),
                                component_version=image,
                                published_date=vuln.get('PublishedDate', 'Unknown'),
                                cvss_score=vuln.get('CVSS', {}).get('nvd', {}).get('V3Score', 0.0),
                                exploit_available=False,
                                remediation=vuln.get('FixedVersion', 'Update to fixed version'),
                                references=[]
                            )
                            vulnerabilities.append(vulnerability)
        
        except Exception as e:
            logger.warning(f"Could not scan Docker image {image}: {str(e)}")
        
        return vulnerabilities
    
    def _scan_application_dependencies(self) -> List[Vulnerability]:
        """Scan application dependencies for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Look for common dependency files
            dependency_files = [
                'package-lock.json',
                'yarn.lock',
                'requirements.txt',
                'Pipfile.lock',
                'pom.xml',
                'build.gradle'
            ]
            
            for dep_file in dependency_files:
                if os.path.exists(dep_file):
                    file_vulns = self._scan_dependency_file(dep_file)
                    vulnerabilities.extend(file_vulns)
        
        except Exception as e:
            logger.error(f"Error scanning application dependencies: {str(e)}")
        
        return vulnerabilities
    
    def _scan_dependency_file(self, file_path: str) -> List[Vulnerability]:
        """Scan a specific dependency file"""
        vulnerabilities = []
        
        try:
            if file_path.endswith('.json'):
                with open(file_path, 'r') as f:
                    data = json.load(f)
                
                if 'dependencies' in data:
                    for name, version_info in data['dependencies'].items():
                        version = version_info if isinstance(version_info, str) else version_info.get('version', 'unknown')
                        pkg_vulns = self._check_package_vulnerabilities(name, version)
                        vulnerabilities.extend(pkg_vulns)
        
        except Exception as e:
            logger.warning(f"Could not scan dependency file {file_path}: {str(e)}")
        
        return vulnerabilities
    
    def _scan_network_services(self) -> List[Vulnerability]:
        """Scan network services for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Get listening services
            if self._is_linux():
                result = subprocess.run(['netstat', '-tlnp'], capture_output=True, text=True)
                
                if result.returncode == 0:
                    for line in result.stdout.split('\n'):
                        if 'LISTEN' in line:
                            parts = line.split()
                            if len(parts) >= 7:
                                address_port = parts[3]
                                service = parts[6] if len(parts) > 6 else 'unknown'
                                
                                # Check for common vulnerable services
                                vulnerable_services = {
                                    'telnet': 'Telnet service detected - consider using SSH',
                                    'ftp': 'FTP service detected - consider using SFTP/FTPS',
                                    'rsh': 'RSH service detected - insecure protocol'
                                }
                                
                                for vuln_service, message in vulnerable_services.items():
                                    if vuln_service in service.lower():
                                        vulnerabilities.append(Vulnerability(
                                            cve_id='SERVICE-VULN',
                                            severity='medium',
                                            title=f'Insecure service: {service}',
                                            description=message,
                                            affected_component=address_port,
                                            component_version='unknown',
                                            published_date=datetime.now().isoformat(),
                                            cvss_score=5.0,
                                            exploit_available=False,
                                            remediation='Replace with secure alternative',
                                            references=[]
                                        ))
        
        except Exception as e:
            logger.error(f"Error scanning network services: {str(e)}")
        
        return vulnerabilities
    
    def generate_report(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Generate vulnerability scan report"""
        # Group by severity
        severity_counts = {}
        for vuln in vulnerabilities:
            severity_counts[vuln.severity] = severity_counts.get(vuln.severity, 0) + 1
        
        # Group by component
        component_counts = {}
        for vuln in vulnerabilities:
            component_counts[vuln.affected_component] = component_counts.get(vuln.affected_component, 0) + 1
        
        # High priority vulnerabilities
        high_priority = [v for v in vulnerabilities if v.severity in ['critical', 'high'] and v.exploit_available]
        
        return {
            "timestamp": datetime.now().isoformat(),
            "summary": {
                "total_vulnerabilities": len(vulnerabilities),
                "severity_breakdown": severity_counts,
                "affected_components": len(component_counts),
                "high_priority_count": len(high_priority)
            },
            "vulnerabilities": [asdict(v) for v in vulnerabilities],
            "recommendations": self._generate_recommendations(vulnerabilities),
            "top_risks": sorted(vulnerabilities, key=lambda x: x.cvss_score, reverse=True)[:10]
        }
    
    def _generate_recommendations(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        if not vulnerabilities:
            recommendations.append("No vulnerabilities detected - system appears secure")
            return recommendations
        
        # Critical vulnerabilities
        critical_vulns = [v for v in vulnerabilities if v.severity == 'critical']
        if critical_vulns:
            recommendations.append(f"URGENT: {len(critical_vulns)} critical vulnerabilities found - patch immediately")
        
        # Exploitable vulnerabilities
        exploitable = [v for v in vulnerabilities if v.exploit_available]
        if exploitable:
            recommendations.append(f"{len(exploitable)} vulnerabilities with known exploits - prioritize patching")
        
        # Component-specific recommendations
        components = list(set(v.affected_component for v in vulnerabilities))
        if len(components) > 5:
            recommendations.append("Many components affected - consider implementing regular patching schedule")
        
        # General recommendations
        recommendations.extend([
            "Implement regular vulnerability scanning and patching",
            "Use automated security updates where possible",
            "Monitor security advisories for affected components",
            "Implement defense-in-depth security measures",
            "Consider using container scanning in CI/CD pipeline"
        ])
        
        return recommendations

def main():
    parser = argparse.ArgumentParser(description='Comprehensive vulnerability scanner')
    parser.add_argument('--scan-type', choices=['all', 'system', 'docker', 'dependencies', 'network'], 
                       default='all', help='Type of scan to perform')
    parser.add_argument('--output', default='vulnerability_scan_report.json')
    
    args = parser.parse_args()
    
    try:
        scanner = VulnerabilityScanner()
        vulnerabilities = scanner.scan_system_vulnerabilities(args.scan_type)
        report = scanner.generate_report(vulnerabilities)
        
        with open(args.output, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        print(f"Vulnerability Scan Summary:")
        print(f"Total vulnerabilities: {report['summary']['total_vulnerabilities']}")
        print(f"Critical: {report['summary']['severity_breakdown'].get('critical', 0)}")
        print(f"High: {report['summary']['severity_breakdown'].get('high', 0)}")
        print(f"Medium: {report['summary']['severity_breakdown'].get('medium', 0)}")
        print(f"Low: {report['summary']['severity_breakdown'].get('low', 0)}")
        print(f"High priority: {report['summary']['high_priority_count']}")
        print(f"Report saved to {args.output}")
        
    except Exception as e:
        logger.error(f"Error during vulnerability scanning: {str(e)}")

if __name__ == "__main__":
    main()
